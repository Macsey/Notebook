# # P3619 魔法

## 题目描述

cjwssb 知道是误会之后，跟你道了歉。你为了逗笑他，准备和他一起开始魔法。不过你的时间不多了，但是更惨的是你还需要完成 $n$ 个魔法任务。假设你当前的时间为 $T$，每个任务需要有一定的限制 $t_i$ 表示只有当你的 $T$ 严格大于 $t_i$ 时你才能完成这个任务，完成任务并不需要消耗时间。当你完成第 $i$ 个任务时，你的时间 $T$ 会加上 $b_i$，此时要保证 $T$ 在任何时刻都大于 $0$，那么请问你是否能完成这 $n$ 个魔法任务，如果可以，输出 $\texttt{+1}\texttt{s}$，如果不行，输出 $\texttt{-1}\texttt{s}$。

## 输入格式

第一行：一个整数 $Z$，表示有 $Z$ 个测试点。

对于每个测试点：

第一行：两个整数 $n,T$，表示有 $n$ 个任务,你一开始有 $T$ 的时间。

接下来 $n$ 行，每行 $2$ 个数字，$t_i$ 与 $b_i$。

## 输出格式

对于每个测试点，输出 $\texttt{+1}\texttt{s}$ 或者 $\texttt{-1}\texttt{s}$。

## 输入输出样例 #1

### 输入 #1

```
1
2 13
1 -9
5 -3
```

### 输出 #1

```
+1s
```

## 说明/提示

对于 $20\%$ 的数据，$n\leq10$；

对于 $100\%$ 的数据，$n\leq10^5,Z\leq10,t_i\leq10^5,T\leq10^5,-10^5\leq b_i\leq 10^5$。

# 解题
## 尝试代码
``` cpp
#include<algorithm>
#include<iostream>
#include<vector>
#include<queue>
#include<map>
using namespace std;
typedef long long ll;
bool cmp(pair<int, int>a, pair<int, int>b) {
	return a.first + a.second > b.first + b.second;
}
int main() {
	int z;
	cin >> z;
	while (z--) {
		vector<pair<ll, ll>>tests;
		ll n;
		ll T;
		cin >> n >> T;
		for (ll i = 0; i < n; i++) {
			ll t, b;
			cin >> t >> b;
			tests.push_back({ t,b });

		}
		sort(tests.begin(), tests.end(), cmp);
		int i = 0;
		for (i = 0; i < n; i++) {
			if (T > tests[i].first) {
				T += tests[i].second;
				if (T <= 0) {
					break;
				}
			}
			else break;
		}
		if (i == n) {
			cout << "+1s" << endl;
		}
		else {
			cout << "-1s" << endl;
		}


	}
	return 0;
}

```

> [!failure] 
> 逻辑错误
## 解题思路

注意到 bi​ 可以是正也可以是负。这会影响我们完成任务的顺序：

1. ​**​bi​≥0 的任务**​：完成这些任务会增加时间 T，因此尽早完成它们是有利的，因为它们可以增加我们的时间储备，帮助我们完成其他任务。
2. ​**​bi​<0 的任务**​：完成这些任务会减少时间 T，因此我们需要谨慎安排它们的顺序，确保在完成它们后仍然有足够的时间完成其他任务。

贪心策略

为了最大化完成所有任务的可能性，我们需要合理安排任务的顺序。通常的贪心策略是：

1. ​**先完成所有 bi​≥0 的任务**​：因为这些任务会增加 T，所以尽早完成它们可以让我们有更多的时间去完成其他任务。对于这些任务，应该按照 ti​ 从小到大的顺序完成，因为这样可以尽早解锁更多的任务。
2. ​**然后完成所有 bi​<0 的任务**​：这些任务会减少 T，因此我们需要找到一个顺序，使得在完成它们的过程中 T 不会降到 0 或以下。对于这些任务，通常的策略是按照 ti​+bi​ 从大到小的顺序完成。这是因为 ti​+bi​ 可以看作是一个“门槛”，较大的 ti​+bi​ 意味着完成任务后剩余的时间相对较多。

## AC代码
``` cpp
#include<algorithm>
#include<iostream>
#include<vector>
#include<queue>
#include<map>
using namespace std;
typedef long long ll;
bool cmp1(pair<int, int>a, pair<int, int>b) {
	return a.first + a.second > b.first + b.second;
}
bool cmp2(pair<int, int>a, pair<int, int>b) {
	return a.first < b.first;
}
int main() {
	int z;
	cin >> z;
	while (z--) {
		vector<pair<ll, ll>>tests1;
		vector<pair<ll, ll>>tests2;
		ll n;
		ll T;
		cin >> n >> T;
		for (ll i = 0; i < n; i++) {
			ll t, b;
			cin >> t >> b;
			if (b >= 0) {
				tests2.push_back({ t,b });
			}
			else
				tests1.push_back({ t,b });


		}
		sort(tests1.begin(), tests1.end(), cmp1);
		sort(tests2.begin(), tests2.end(), cmp2);

		bool possible = true; //使用possible来完成阶段性检测
		for (int i = 0; i < tests2.size(); i++) {
			if (T > tests2[i].first) {
				T += tests2[i].second;
				if (T <= 0) {
					possible = false;
					break;
				}
			}
			else {
				possible = false;
				break;

			}
		}
		if (!possible) {
			cout << "-1s" << endl;
			continue;
		}
		else {
			for (int j = 0; j < tests1.size(); j++) {
				if (T > tests1[j].first) {
					T += tests1[j].second;
					if (T <= 0) {
                        possible = false;
						break;
					}
				}
                else {
					possible = false;
					break;

				}
			}
		}
		if (possible) {
			cout << "+1s" << endl;
		}
		else {
            cout << "-1s" << endl;
		}
	}
	return 0;
}

```






