## 前端与后端分离
- **前端**：与用户交互（如 Python/R/Scala/C++），负责发送计算指令，不执行实际计算，避免 Python 单线程瓶颈。
- **后端**：基于 C++ 实现，管理独立线程，持续收集前端排队的任务并执行，同时跟踪计算图中操作的依赖关系（相互依赖的操作无法并行）。
**交互逻辑**：前端将操作传递到后端队列后立即返回控制权，后端异步执行任务；仅当前端需要结果
才等待后端完成计算。
## 障碍器与阻塞器
显式阻塞操作（强制同步）
隐式阻塞操作（自动触发同步）


| 计算方式 | 实现逻辑                         | 耗时      | 性能提升原理                                          |
| ---- | ---------------------------- | ------- | ----------------------------------------------- |
| 同步计算 | 每次加法后用`wait_to_read()`阻塞     | 3.5791s | 总耗时 = 10000×(前端指令时间 t1 + 后端计算时间 t2 + 结果返回时间 t3) |
| 异步计算 | 先排队所有任务，最后用`npx.waitall()`同步 | 0.7830s | 总耗时 = t1 + 10000×t2 + t3                        |
