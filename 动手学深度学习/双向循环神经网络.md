## 解决的问题：下文推上文
## 隐马尔可夫模型中的动态规划
前向递归和反向递归
![[Pasted image 20251209211932.png]]
本质： 一步一步算，存下中间结果，避免重复计算，计算量从指数级变为线性级
## 双向模型
![[Pasted image 20251209212848.png]]
如图：双向循环神经网络 添加了反向传递信息的隐藏层，以便更灵活地处理此类信息
### 定义
对于任意时间步 $t$，给定一个小批量的输入数据 $\boldsymbol{X}_t \in \mathbb{R}^{n \times d}$（样本数 $n$，每个示例中的输入数 $d$），并且隐层激活函数为 $\phi$。在双向架构中，我们设该时间步的前向和反向隐状态分别表示为 $\overrightarrow{\boldsymbol{H}}_t \in \mathbb{R}^{n \times h}$ 和 $\overleftarrow{\boldsymbol{H}}_t \in \mathbb{R}^{n \times h}$，其中 $h$ 是隐藏单元的数目。
前向和反向状态的更新如下所示：
#### 前向和反向隐状态更新
$$\begin{split}\begin{aligned}
\overrightarrow{\mathbf{H}}_t &= \phi(\mathbf{X}_t \mathbf{W}_{xh}^{(f)} + \overrightarrow{\mathbf{H}}_{t-1} \mathbf{W}_{hh}^{(f)}  + \mathbf{b}_h^{(f)}),\\
\overleftarrow{\mathbf{H}}_t &= \phi(\mathbf{X}_t \mathbf{W}_{xh}^{(b)} + \overleftarrow{\mathbf{H}}_{t+1} \mathbf{W}_{hh}^{(b)}  + \mathbf{b}_h^{(b)}),
\end{aligned}\end{split}$$
事实上，这两个方向可以拥有不同数量的隐藏单元。
其中，权重 $\boldsymbol{W}_{xh}^{(f)} \in \mathbb{R}^{d \times h}$，$\boldsymbol{W}_{hh}^{(f)} \in \mathbb{R}^{h \times h}$，$\boldsymbol{W}_{xh}^{(b)} \in \mathbb{R}^{d \times h}$，$\boldsymbol{W}_{hh}^{(b)} \in \mathbb{R}^{h \times h}$ 和偏置 $\boldsymbol{b}_h^{(f)} \in \mathbb{R}^{1 \times h}$，$\boldsymbol{b}_h^{(b)} \in \mathbb{R}^{1 \times h}$ 都是模型参数。

#### 输出层计算

接下来，将前向隐状态 $\overrightarrow{\boldsymbol{H}}_t$ 和反向隐状态 $\overleftarrow{\boldsymbol{H}}_t$ 连接起来，获得需要输入输出层的隐状态 $\boldsymbol{H}_t \in \mathbb{R}^{n \times 2h}$。在具有多个隐藏层的深度双向循环神经网络中，该信息会输入传递到下一个双向层。

最后，输出层计算得到的输出为 $\boldsymbol{O}_t \in \mathbb{R}^{n \times q}$（$q$ 是输出单元的数目）：

$$\boldsymbol{O}_t = \boldsymbol{H}_t \boldsymbol{W}_{hq} + \boldsymbol{b}_q \tag{9.4.8}$$

这里，权重矩阵 $\boldsymbol{W}_{hq} \in \mathbb{R}^{2h \times q}$ 和偏置 $\boldsymbol{b}_q \in \mathbb{R}^{1 \times q}$ 是输出层的模型参数。

### 模型的计算代价及其应用
双向循环神经网络的一个**关键特性**是：**使用来自序列两端的信息来估计输出**。（我们使用来自过去和未来的观测信息来预测当前的观测）
**缺点**：
1. **精度差**
训练期间，我们能够利用过去和未来的数据来估计现在空缺的词； 
测试期间，我们只有过去的数据，因此精度将会很差。
2. **速度慢**
**原因**：网络的前向传播需要在双向层中进行前向和后向递归， 并且网络的反向传播还依赖于前向传播的结果。 因此，梯度求解将有一个非常长的链。

#### 应用场合
填充缺失的单词、词元注释（例如，用于命名实体识别） 以及作为序列处理流水线中的一个步骤对序列进行编码（例如，用于机器翻译）。