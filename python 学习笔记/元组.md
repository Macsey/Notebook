![[Pasted image 20250807222720.png]]

# 不可赋值
![[Pasted image 20250807222827.png]]

# 内容可变
![[Pasted image 20250807222904.png]]

# 元组切片
![[Pasted image 20250807223117.png]]

# 元组运算与迭代
![[Pasted image 20250807223317.png]]

# 元组赋值
![[Pasted image 20250807223526.png]]
注意： x+=(100,)相当于新建了一个元组，然后让x指向那一个元组（不能在元组后面添加新的元素）
tip:在python中每一个变量都相当于是一个指针

# 元组比较大小
![[Pasted image 20250807223910.png]]

# 元组的应用：万年历
![[Pasted image 20250807225341.png]]
数学方法快速计算出整年的天数：

注意：如果year=2016；2016并不能算是一整年，所以要减一。
![[Pasted image 20250807225835.png]]
用datetime包实现万年历 
![[Pasted image 20250807230458.png]]


# 深度学习中的 “元组”：从基础概念到实战应用

在之前讲解字典时，我们提到 “不能用列表当字典的键，但可以用元组”，很多同学可能会好奇：“元组到底是什么？和列表、字典有啥区别？在深度学习里又能用来做什么？” 今天就用最通俗的语言，把元组的本质、用法和实战价值讲明白，帮你打通深度学习中的 “数据容器” 知识链。

## 一、先搞懂：元组到底是个啥？（生活类比版）

你可以把代码里的 “元组”，理解成**现实中 “封了口的快递盒”**—— 里面可以装多个不同的东西（比如一个苹果、一把尺子、一张卡片），但一旦打包封好，就不能随便添加、删除或修改里面的物品；而且盒子里的东西有固定顺序，不会像字典那样靠 “标签” 查找，而是靠 “位置” 定位。

举个生活例子：

你去超市买东西，结账时收银员把你的 “面包、牛奶、鸡蛋” 装在一个密封袋里，这个密封袋就是一个 “元组”：

- 里面的物品有固定顺序（面包在第一个、牛奶在第二个、鸡蛋在第三个）；

- 密封袋一旦封好，不能再往里面加一瓶可乐，也不能把牛奶拿出来换成果汁；

- 想拿牛奶，只能记住它在 “第二个位置”，直接从对应位置取，而不是像字典那样按 “牛奶标签” 找。

代码里的 “元组”，就是这个 “封了口的有序快递盒”，核心特点可以总结为两点：

1. **不可变**：创建后不能修改、添加、删除里面的元素（就像密封袋不能拆改）；

2. **有序**：元素有固定位置，可通过 “索引”（比如第 0 位、第 1 位）查找（就像快递盒里的物品按顺序摆放）。

## 二、元组 vs 列表 vs 字典：3 分钟分清核心区别

很多初学者会把元组和列表、字典搞混，其实只要记住 “一句话定位”，就能轻松区分：

- **列表**：可修改的有序容器（像 “敞口的购物篮”，能随时加东西、拿东西、换东西）；

- **字典**：可修改的无序容器（像 “带标签的收纳盒”，靠标签找东西，能随时改标签或换内容）；

- **元组**：不可修改的有序容器（像 “封口的快递盒”，按位置找东西，一旦封好就不能改）。

我们用一张表更直观地对比三者的核心差异：

|   |   |   |   |
|---|---|---|---|
|特性|元组（Tuple）|列表（List）|字典（Dictionary）|
|语法格式|用小括号 () 包裹（如 (1,2,3)）|用中括号 [] 包裹（如 [1,2,3]）|用大括号 {} 包裹键值对（如 {"a":1,"b":2}）|
|是否有序|有序（靠位置索引查找）|有序（靠位置索引查找）|无序（靠键查找，Python 3.7 + 后伪有序）|
|是否可修改|不可修改（不能增删改元素）|可修改（能增删改元素）|可修改（能增删改键值对）|
|查找方式|只能按位置索引（如 t[0]）|只能按位置索引（如 l[0]）|只能按键查找（如 d["a"]）|
|适用场景|存储固定不变的有序数据|存储需要动态调整的有序数据|存储需要 “标签对应” 的无序数据|

## 三、代码里的元组：怎么创建、怎么用？（实战入门）

在 Python（深度学习常用语言）里，元组的用法很简单，核心围绕 “创建” 和 “读取”（因为不能修改），我们结合深度学习中的常见场景一步步学。

### 1. 第一步：创建元组（打包 “快递盒”）

创建元组主要有两种方式：用小括号 () 包裹元素，或直接用逗号分隔元素（小括号可省略，但推荐加上，更直观）。

#### （1）创建普通元组（装多个固定数据）

比如在深度学习中，我们可能需要存储 “数据集的尺寸（高、宽、通道数）”，这些尺寸一旦确定就不会变，适合用元组：

```python
# 方式1：用小括号包裹（推荐，可读性强）

img_shape = (224, 224, 3) # 高224、宽224、通道数3（RGB图像）

print(img_shape) # 输出：(224, 224, 3)

print(type(img_shape)) # 输出：<class 'tuple'>（确认是元组类型）

# 方式2：省略小括号（仅单个元素时需注意，必须加逗号）

img_shape2 = 224, 224, 3 # 和上面效果一样

print(img_shape2) # 输出：(224, 224, 3)

# 注意：创建单个元素的元组，必须加逗号（否则会被当成普通变量）

single_tuple = (5,) # 正确：单个元素的元组

print(type(single_tuple)) # 输出：<class 'tuple'>

wrong_single = (5) # 错误：这是一个整数，不是元组

print(type(wrong_single)) # 输出：<class 'int'>
```

#### （2）创建 “混合类型” 元组（装不同类型的数据）

元组里的元素可以是不同类型（比如整数、字符串、张量），这在深度学习中很常用。比如存储 “模型的基本信息（名称、输入维度、输出类别数）”：

```python
import torch

# 元组包含字符串、整数、张量三种类型

model_info = (

"ResNet50", # 模型名称（字符串）

3, # 输入图像通道数（整数）

torch.tensor([1000]) # 输出类别数（张量）

)

print(model_info) # 输出：('ResNet50', 3, tensor([1000]))
```

### 2. 第二步：使用元组（读取 “快递盒” 里的东西）

因为元组不可修改，所以核心操作是 “按位置读取元素”，用法和列表类似，通过 “索引”（从 0 开始）定位。

#### （1）按索引读取单个元素

比如我们想从 img_shape 元组中获取 “图像的高度”（第 0 位）和 “通道数”（第 2 位）：

```python
img_shape = (224, 224, 3)

# 读取第0位元素（高度）

height = img_shape[0]

print(height) # 输出：224

# 读取第2位元素（通道数）

channels = img_shape[2]

print(channels) # 输出：3

# 支持“负索引”（从末尾开始数，-1是最后一位）

channels = img_shape[-1] # 和img_shape[2]效果一样

print(channels) # 输出：3
```

#### （2）“解包” 读取多个元素（一次性拿多个东西）

如果元组的元素数量固定，我们可以直接把元素 “解包” 到多个变量里，这在深度学习中处理 “多返回值” 时非常方便。比如模型训练函数返回 “训练损失、验证损失、准确率”，这三个值用元组返回后，可直接解包：

```python
# 模拟训练函数返回的元组（训练损失、验证损失、准确率）

train_result = (0.25, 0.32, 0.88)

# 解包：把元组的3个元素分别赋值给3个变量

train_loss, val_loss, acc = train_result

print(f"训练损失：{train_loss}") # 输出：训练损失：0.25

print(f"验证损失：{val_loss}") # 输出：验证损失：0.32

print(f"准确率：{acc}") # 输出：准确率：0.88

# 注意：解包时变量数量必须和元组元素数量一致，否则会报错

# 错误示例：元组有3个元素，只给2个变量

# train_loss, val_loss = train_result # 报错：too many values to unpack (expected 2)
```

#### （3）切片读取多个元素（拿连续的一组东西）

和列表类似，元组也支持 “切片”（用 [起始索引:结束索引]），读取连续的多个元素，返回的结果还是一个元组。比如从 model_info 元组中读取 “模型名称和输入通道数”：

```python
model_info = ("ResNet50", 3, torch.tensor([1000]))

# 切片：读取第0位到第1位（结束索引不包含，所以是0和1两个元素）

basic_info = model_info[0:2]

print(basic_info) # 输出：('ResNet50', 3)

print(type(basic_info)) # 输出：<class 'tuple'>（切片结果还是元组）

# 简化写法：起始索引为0时可省略

basic_info2 = model_info[:2] # 和model_info[0:2]效果一样

print(basic_info2) # 输出：('ResNet50', 3)
```

### 3. 关键提醒：元组真的 “完全不能改” 吗？

这里要区分一个细节：元组的 “不可变”，指的是 “元素的位置和引用不可变”，但如果元素本身是 “可修改的容器”（比如列表、字典），那么元素内部的内容是可以改的。

举个例子：元组里装了一个列表，列表里面的元素可以修改，但不能把整个列表换成其他元素：

```python
# 元组包含一个列表（列表是可修改的）

tuple_with_list = (1, [2, 3, 4], 5)

# 错误：不能修改元组的元素（不能把列表换成6）

# tuple_with_list[1] = 6 # 报错：'tuple' object does not support item assignment

# 正确：可以修改元组中“列表元素内部的内容”

tuple_with_list[1].append(6) # 给列表添加一个元素6

print(tuple_with_list) # 输出：(1, [2, 3, 4, 6], 5)
```

不过在深度学习中，我们很少用元组装可修改的容器，更多是用元组存储 “纯固定数据”（如尺寸、参数配置），所以不用过分纠结这个细节。

## 四、深度学习里为啥要用元组？（3 个核心场景）

元组看似 “功能单一”（不能修改），但在深度学习中却有不可替代的作用，主要集中在以下 3 个场景：

### 1. 存储 “固定配置信息”：避免误修改

深度学习中很多配置信息一旦确定就不能变（比如图像尺寸、 batch size、输入输出维度），用元组存储可以防止代码中不小心修改这些关键值，避免出现 bug。

比如定义卷积层时，需要指定 “输入通道数、输出通道数、卷积核尺寸”，这些参数是固定的，用元组传递更安全：

```python
import torch.nn as nn

# 用元组存储卷积层的固定配置

conv_config = (3, 64, 3) # 输入通道数3、输出通道数64、卷积核尺寸3×3

# 用元组解包创建卷积层（代码更简洁，且配置不会被误改）

conv_layer = nn.Conv2d(

in_channels=conv_config[0], # 读取元组第0位（输入通道数）

out_channels=conv_config[1], # 读取元组第1位（输出通道数）

kernel_size=conv_config[2] # 读取元组第2位（卷积核尺寸）

)
```

如果用列表存储 conv_config = [3,64,3]，万一后面代码不小心写了 conv_config[0] = 1，就会导致卷积层输入通道数错误，而元组能从根本上避免这种问题。

### 2. 作为 “字典的键”：弥补字典的限制

之前讲字典时提到 “不能用列表当键，因为列表是可变的”，而元组是不可变的，所以可以作为字典的键。这在深度学习中 “给不同配置的模型分类” 时非常有用。

比如我们有多个模型，需要用字典存储 “模型配置→模型实例” 的对应关系，模型配置（输入通道数、输出类别数）用元组当键：

```python
import torch.nn as nn

# 定义两个不同配置的模型

model1 = nn.ResNet50(num_classes=1000) # 输出1000类

model2 = nn.ResNet50(num_classes=10) # 输出10类

# 用元组当字典的键，存储“配置→模型”的对应关系

model_dict = {

(3, 1000): model1, # 键：(输入通道数3, 输出类别数1000)

(3, 10): model2 # 键：(输入通道数3, 输出类别数10)

}

# 后续根据配置找模型：比如需要“输入3通道、输出10类”的模型

target_model = model_dict[(3, 10)]

print(target_model) # 输出：ResNet(...)（找到对应的模型实例）
```

如果用列表 [3,1000] 当键，代码会直接报错，而元组完美解决了 “用多维度配置当字典键” 的需求。

### 3. 处理 “多返回值”：简化代码逻辑

深度学习中的很多函数需要返回多个值（比如训练函数返回损失、准确率、学习率；数据加载函数返回图像、标签、文件名），用元组返回后，调用者可以直接 “解包”，不用像列表那样记顺序还担心被修改。

比如一个自定义的数据加载函数，返回 “图像张量、标签、图像路径”：

```python
import torch

def load_data(image_path):

# 模拟加载图像（这里用随机张量代替）

img = torch.randn(3, 224, 224) # 3通道、224×224图像

label = 5 # 图像标签

# 用元组返回多个值（不用刻意写括号，逗号分隔即可）

return img, label, image_path

# 调用函数，直接解包元组结果

img_tensor, img_label, img_path = load_data("data/cat.jpg")

print(f"标签：{img_label}") # 输出：标签：5

print(f"图像形状：{img_tensor.shape}") # 输出：图像形状：torch.Size([3, 224, 224])
```

这种方式比用列表返回更安全（不用担心返回值被修改），也比用字典返回更简洁（不用写键名，直接按顺序解包）。

## 五、常见问题：元组的 “坑” 和注意事项

### 1. 不要试图修改元组：会直接报错

元组的核心特性是 “不可变”，所以任何试图修改元组的操作（添加、删除、修改元素）都会报错，这是初学者最容易踩的坑：

```python
t = (1, 2, 3)

# 错误1：修改元素

# t[0] = 4 # 报错：'tuple' object does not support item assignment

# 错误2：添加元素（元组没有append方法）

# t.append(4) # 报错：'tuple' object has no attribute 'append'

# 错误3：删除元素（元组没有remove方法）

# t.remove(2) # 报错：'tuple' object has no attribute 'remove'
```

如果确实需要修改数据，应该用列表，而不是元组。

### 2. 元组的 “不可变” 是 “表层” 的：元素内部可能可变

前面提到过，如果元组的元素是 “可修改的容器”（如列表、字典），元素内部的内容是可以改的。比如：

```python
# 元组包含一个字典（字典是可修改的）

t = (1, {"a": 2}, 3)

# 可以修改元组中字典的键值对

t[1]["a"] = 4

print(t) # 输出：(1, {'a': 4}, 3)
```

这种情况在深度学习中很少见，但遇到时要知道 “元组的不可变是指元素的引用不变，不是元素内容绝对不变”。

### 3. 元组的 “切片” 返回的还是元组：避免类型混淆

和列表不同，元组切片后得到的结果依然是元组，而不是列表。这一点在深度学习中处理固定格式数据时很重要，能保证数据类型的一致性，避免后续代码因类型错误报错。

举个例子：我们用元组存储 “一批图像的尺寸信息（高、宽、通道数、 batch 大小）”，切片获取前三个维度（高、宽、通道数），结果还是元组，可直接用于图像预处理函数（该函数要求输入尺寸为元组类型）：

```python
# 元组存储：(batch大小, 高, 宽, 通道数)

batch_shape = (32, 224, 224, 3)

# 切片获取前三个维度（高、宽、通道数）

img_shape = batch_shape[1:4] # 从索引1开始，到索引4结束（不包含4）

print(img_shape) # 输出：(224, 224, 3)

print(type(img_shape)) # 输出：<class 'tuple'>（切片结果仍是元组）

# 直接传入图像预处理函数（要求输入为元组类型）

def preprocess_image(shape):

print(f"图像尺寸：{shape}，开始预处理...")

preprocess_image(img_shape) # 正常运行，输出：图像尺寸：(224, 224, 3)，开始预处理...
```

如果用列表切片，结果会是列表，若函数要求元组输入，就需要额外转换类型（如 tuple(list_slice)），而元组切片则省去了这一步，让代码更简洁。

## 六、元组在深度学习 “文件读写” 中的实战应用（结合文档内容）

在之前讲解的深度学习文件读写场景中（如存储张量、模型参数），元组虽然不直接参与 “写文件” 操作，但在 “数据准备” 和 “参数配置” 环节扮演着重要角色，能帮我们规范数据格式，避免读写后的数据出现混乱。

结合文档中 “5.5 读写文件” 的内容，我们看看元组的具体应用：

### 1. 定义 “固定数据格式”，确保读写后数据一致性

文档中提到 “存储张量列表或字典” 时，若张量对应的是 “固定维度的数据”（如图像、文本序列），可用元组先定义数据维度，再基于该维度创建张量，确保写入文件的张量格式统一，读取后也能快速验证维度是否正确。

例如，我们要存储 “一批文本数据的张量（batch 大小 = 2，序列长度 = 10，词向量维度 = 50）”：

```python
import torch

# 用元组定义文本数据的固定维度：(batch大小, 序列长度, 词向量维度)

text_dim = (2, 10, 50)

# 基于元组维度创建张量（确保张量格式符合预期）

text_tensor = torch.randn(text_dim) # 形状为(2,10,50)的张量

# 按文档方法，将张量存入字典后写入文件

data_dict = {"text_data": text_tensor, "dim_info": text_dim} # 元组也能直接存入字典

torch.save(data_dict, "text_data.pth")

# 读取文件后，用元组验证数据维度是否正确

loaded_dict = torch.load("text_data.pth")

loaded_tensor = loaded_dict["text_data"]

loaded_dim = loaded_dict["dim_info"]

# 验证维度：元组比较直接，结果为布尔值

if loaded_tensor.shape == loaded_dim:

print("数据维度正确，可正常使用") # 输出：数据维度正确，可正常使用

else:

print("数据维度异常，需检查")
```

这里元组的作用是 “提供固定的维度标准”，避免写入文件的张量因维度错误（如少了一个维度）导致后续模型训练报错，读取后也能通过元组快速校验，确保数据可用性。

### 2. 存储 “模型参数配置”，辅助读取参数后的模型初始化

文档中强调 “保存模型参数时，需单独用代码定义模型架构”，而模型架构的关键参数（如输入维度、隐藏层数量、输出类别数）可用元组存储，读取模型参数后，基于元组快速初始化模型，避免手动输入参数时出现遗漏或错误。

例如，基于文档中的 MLP 模型，用元组存储模型配置：

```python
import torch

from torch import nn

# 用元组存储MLP模型的固定配置：(输入维度, 隐藏层节点数, 输出类别数)

mlp_config = (20, 256, 10)

# 基于元组配置定义模型架构（参数直接从元组读取，避免硬编码错误）

class MLP(nn.Module):

def __init__(self, config):

super().__init__()

in_dim, hidden_dim, out_dim = config # 元组解包，快速赋值

self.hidden = nn.Linear(in_dim, hidden_dim) # 输入维度=20，隐藏层=256

self.output = nn.Linear(hidden_dim, out_dim) # 隐藏层=256，输出=10

def forward(self, x):

return self.output(F.relu(self.hidden(x)))

# 初始化模型并训练（略去训练过程）

net = MLP(mlp_config)

X = torch.randn(size=(2, mlp_config[0])) # 输入维度从元组读取，确保匹配

Y = net(X)

# 按文档方法保存模型参数

torch.save(net.state_dict(), "mlp.params")

# 读取参数后，基于同一元组快速初始化模型

clone = MLP(mlp_config) # 直接用元组配置，无需重复输入20、256、10

clone.load_state_dict(torch.load("mlp.params"))

clone.eval()

# 验证模型：输入相同数据，输出一致

Y_clone = clone(X)

print(Y_clone == Y) # 输出全为True，模型初始化正确
```

这里元组的作用是 “统一模型配置入口”，无论是初始化原始模型还是读取参数后的克隆模型，都基于同一个元组，避免因手动输入参数（如把隐藏层节点数写成 255）导致模型架构不匹配，进而无法加载参数的问题。

## 七、元组的核心优势总结：为什么在深度学习中离不开它？

回顾前面的内容，元组看似 “功能简单”，但在深度学习中能解决很多关键问题，核心优势可总结为三点：

1. **安全性**：不可变特性避免关键数据（如维度、配置）被误修改，减少因数据篡改导致的训练或推理错误；

2. **简洁性**：支持解包和切片，能快速处理多维度数据，简化代码逻辑（如模型配置赋值、多返回值处理）；

3. **兼容性**：可作为字典的键，弥补字典对 “可变键” 的限制，同时切片后仍保持元组类型，确保数据格式一致性。

在实际深度学习项目中，元组常与列表、字典配合使用：用元组存储固定配置，用列表存储动态数据，用字典存储 “标签 - 数据” 对应关系，三者分工明确，共同构建高效、稳定的代码体系。

比如一个完整的图像分类项目流程：

- 用元组 img_config = (224, 224, 3) 定义图像尺寸；

- 用列表 train_paths = [path1, path2, ...] 存储动态变化的训练图像路径；

- 用字典 model_dict = {(3, 10): model1, (3, 100): model2} 存储不同配置的模型；

- 读写文件时，将元组、列表、字典结合，确保数据和参数的安全存储与高效读取。

掌握元组的用法，能让你在处理深度学习数据和参数时更得心应手，避免很多不必要的 “低级错误”，为后续复杂模型开发打下坚实基础。