这是一个非常全面的C++期末复习题集，涵盖了面向对象编程核心（继承、多态）、泛型编程（模板）以及错误处理（异常）的重点难点。

鉴于你是一位大二学生，且有一定的计算机基础（CS、硬件、系统编程兴趣），我将以**“底层内存模型 + 语法特性解析 + 代码实现”**的思路为你逐一详细解析。

我将按照你偏好的 **Allman 风格**（独占一行的花括号）和 **CamelCase 命名法** 来编写示例代码，但题目中已有的函数名（如 `modify_score`）我会保持原样以对应题目。

---

### 第一部分：继承和多态 (Inheritance & Polymorphism)

#### 1. 对象模型与构造/析构 (Source 3-7)

> **Q:** `Student s1; Graduate s2;` 调用哪些函数？`s1` 和 `s2` 占用多少内存？

- **调用函数：**
    
    - `s1`: 调用 `Student` 的默认构造函数。
        
    - `s2`: 先调用 `Student` 的默认构造函数（基类部分），再调用 `Graduate` 的默认构造函数（派生类部分）、`_supervisor` (MyString) 的默认构造函数。
        
    - **析构顺序相反：** `s2` 销毁时，先析构 `Graduate` (及成员 `_supervisor`)，再析构 `Student`。
        
- **内存空间 (Sizeof)：**
    
    - **Student:** `sizeof(_number) + sizeof(_name) + sizeof(_major) + sizeof(_score)`。由于存在**虚函数**（题目提到析构函数为虚），对象内会增加一个 **vptr (虚函数指针)**，通常占 4 或 8 字节（取决于 32/64位系统）。注意**内存对齐 (Padding)**。
        
    - **Graduate:** `sizeof(Student)` (含基类数据+vptr) + `sizeof(_supervisor)`。不需要额外的 vptr，派生类共用基类的 vptr（但指向不同的 vtable）。
        

#### 2. 数组与指针的构造 (Source 8-12)

> **Q:** `Student * p = new Graduate[2]; delete [] p;`

- **构造函数：** `Student` 和 `Graduate` 必须有**无参默认构造函数**，因为数组初始化默认调用无参构造。
    
- **函数调用：**
    
    - `new`: 调用 2 次 `Student` 构造 -> 2 次 `Graduate` 构造。
        
    - `delete []`: **这是一个典型的未定义行为 (Undefined Behavior) 陷阱！**
        
        - 原因：`p` 是 `Student*` 类型，`delete [] p` 会根据 `sizeof(Student)` 来计算下一个元素的位置。但实际对象是 `Graduate`，大小不同。编译器无法正确找到第二个对象的地址进行析构。
            
        - **如果只是 `delete p` (单个对象)** 且基类析构是虚函数，则没问题。但 `delete []` 对多态数组支持极差，**切勿多态地使用对象数组**。
            

#### 3. 参数传递与对象切片 (Source 13-24)

> **Q:** `modify_score` 调用分析。

- `modify_score(s, 100)` (引用版): 传递引用，**不产生新对象**，不调用构造/析构。直接修改 `s`。
    
- `modify_score(&g, 100)` (指针版): 传递地址，**不产生新对象**。
    
    - 注意：虽然传的是 `Graduate*`，但参数接收是 `Student*`。由于 `set_score` 通常不是虚函数（或是基类函数），直接调用基类版本修改基类部分的 `_score`。
        

#### 4. 复制构造函数与深拷贝 (Source 25-41)

> **Q:** `fun(g)` 调用分析。

- `fun(Graduate& s)` 参数是引用，**不调用复制构造函数**。
    
- `s.get_name().set_string(...)`: 修改了对象内部数据。
    
- `return s`: **关键点！** 函数返回类型是 `Graduate`（值类型）。这里会调用 **`Graduate` 的复制构造函数**，将 `s` 拷贝到一个临时对象返回给调用者。
    
- **Source 32 的实现：** `: Student(g), _supervisor(g._supervisor)`。这是正确的写法，显式调用基类复制构造函数，处理基类部分数据。
    

#### 5. 错误的复制构造写法 (Source 42-46)

> **Q:** 如果复制构造函数写成 `Student::operator=(g)` 会怎样？



```C++
Graduate(const Graduate& g)
{
    Student::operator=(g); // 错误！
    _supervisor = g._supervisor;
}
```

- **解析：** 构造函数执行函数体之前，基类部分**已经被默认构造**（调用了 `Student()`）。
- **隐式基类初始化 (隐形步骤)**： 在进入 `{` 之前，编译器**必须**先构造父类部分。因为你没有在初始化列表中指定怎么构造，编译器只能默认调用**无参构造函数**。
    
    - **调用函数：** `Student()` (Student 的默认构造函数) 。
        
    - **后果：** 此时新对象的基类部分被初始化为一个“空”学生（由于默认构造函数通常为空或赋默认值）。
        
- **隐式成员初始化 (隐形步骤)**： 同样，`_supervisor` 成员也必须在进入函数体前初始化。
    
    - **调用函数：** `MyString()` (MyString 的默认构造函数)。
        
    - **后果：** 产生了一个空的导师名字对象。
        
- **执行函数体 - 基类赋值**： 进入函数体，执行 `Student::operator=(g);` 。
    
    - **调用函数：** `Student::operator=(const Student& s)` 。
        
    - **行为：** 这是一个**赋值操作**。它将 `g` 中的数据覆盖掉刚才第一步里生成的那个“空”学生的数据。
        
- **执行函数体 - 成员赋值**： 执行 `_supervisor = g._supervisor;` 。
    
    - **调用函数：** `MyString::operator=(const MyString&)` (MyString 的赋值运算符)。
        
    - **行为：** 将 `g` 的导师名字覆盖掉刚才第二步里生成的空名字。
- 这里你先创建了一个空的基类部分，然后立刻调用赋值运算符覆盖它。虽然结果可能正确，但效率低（构造+赋值），且如果 `Student` 没有默认构造函数，代码将无法编译。
    

#### 6. Graduate 赋值运算符 (Source 59)

需要先调用基类的赋值运算符，再处理自己的成员。



```C++
Graduate& operator=(const Graduate& s)
{
    if (this != &s)
    {
        Student::operator=(s); // 显式调用基类赋值运算符
        _supervisor = s._supervisor;
    }
    return *this;
}
```

#### 7. 移动语义 (Source 60)

- **需要吗？** 如果 `MyString` 管理堆内存（如 `char*`），实现移动构造/赋值能大幅提升性能（避免深拷贝）。
    
- **实现：** 使用 `std::move` 强制转换为右值引用。
    

C++

```
Graduate(Graduate&& s) noexcept 
    : Student(std::move(s)), _supervisor(std::move(s._supervisor)) 
{ 
}
```

#### 8. 虚函数 Write/Read (Source 61-68)
1. 为什么 `Student` 类的 `read` 函数要设为虚函数？

**核心原因：为了实现多态调用，确保“读完整”。**

- **场景假设：** 在实际的文件读取或管理系统中，我们通常会使用基类指针 `Student*` 来统一管理所有的学生对象（既包含本科生 `Student`，也包含研究生 `Graduate`）。
    
- **如果不设为虚函数：** 如果 `read` 只是普通成员函数，当我们使用 `Student* p = new Graduate();` 并没有虚函数机制时，执行 `p->read(in)`，编译器会根据指针类型（`Student*`）直接调用 `Student::read()`。
    
    - **后果：** 程序只会读取“学号、姓名、专业、成绩”，而**漏掉**了研究生独有的“导师姓名（_supervisor）”。这会导致数据读取不完整，甚至导致文件指针位置错乱。
        
- **设为虚函数后：** 编译器会通过指针指向的对象的 **vptr（虚函数指针）** 查找虚函数表。只要实际对象是 `Graduate`，就会正确调用 `Graduate::read()`，从而先读基类数据，再读导师数据 。
2. 根据题目给出的基类原型 `virtual Student * Student::read(istream & in);`，实现的核心逻辑是：**先调用父类读基础数据，再读自己的数据，最后返回自身指针。**
这里利用了 C++ 的**协变返回类型**特性（即派生类重写虚函数时，返回类型可以是基类返回类型的派生类指针）。虽然基类返回 `Student*`，但 `Graduate` 最好返回 `Graduate*`（更精确），当然返回 `Student*` 也是合法的。

**代码实现如下：**
```C++
// 假设这是在 Graduate 类内部或定义
Student* Graduate::read(istream & in)
{
    // 1. 显式调用基类的 read 函数，读取 name, major, score 等基础信息
    Student::read(in); 

    // 2. 调用成员对象 _supervisor (MyString) 的 read 函数读取导师信息
    _supervisor.read(in);

    // 3. 返回当前对象的地址
    return this; 
}
```
3.如果基类声明返回引用，`Graduate` 类应如何声明？

**题目条件：** 基类改为 `virtual Student& Student::read(istream & in);`

**解析：** 这涉及到 C++ 的**协变返回类型 (Covariant Return Types)** 规则。 当派生类覆盖（Override）基类的虚函数时，如果基类函数返回的是**基类的指针或引用**（如 `Student*` 或 `Student&`），派生类的覆盖函数可以返回**派生类的指针或引用**（如 `Graduate*` 或 `Graduate&`）。

**`Graduate` 类的声明应该如下（两种写法均可，建议第一种）：**

**写法 A（推荐，利用协变特性）：**

C++

```
// 返回类型改为 Graduate&，这提供了更强的类型信息
virtual Graduate& read(istream & in) override; 
```

- **为什么要虚函数？** 为了支持多态调用。`Student* p = new Graduate(...)`，调用 `p->write()` 时，如果不是虚函数，只会保存基类数据，丢失 `Graduate` 特有的 `_supervisor`。
    
- **Read 的协变返回类型：**
    
    - 如果基类声明 `virtual Student* read(...)`。
        
    - 派生类可以覆盖为 `virtual Graduate* read(...)`。这是 C++ 允许的**协变 (Covariant)**，即返回类型可以是基类返回类型的派生类指针/引用。
        

#### 9. 多重继承与构造顺序 (Source 69-78)

> `class C : public A, public B`

- **构造顺序：** 取决于**继承声明顺序**，而非初始化列表顺序。
    
    1. `A()`
        
    2. `B()`
        
    3. `s1` (MyString)
        
    4. `s2` (MyString)
        
    5. `C()` 构造函数体。
        

#### 10. StudentList 管理类 (Source 79-106)

### (1) 复制构造函数和复制赋值运算符

**结论：应该实现，且必须实现“深拷贝”。**

- **理由：** `StudentList` 内部有一个裸指针数组 `_ppStu`，且数组里存的也是指向堆内存的指针 `Student*`。
    
    - 如果使用默认的复制构造（浅拷贝），两个 `StudentList` 对象将指向同一块内存。当其中一个对象析构时，所有的学生对象都会被删除，另一个对象就变成了“悬空指针”，一旦使用或析构会导致程序崩溃（Double Free）。
        
- **实现难点（多态复制）：** 数组里存的是 `Student*`，但实际对象可能是 `Graduate`。如果我们只用 `new Student(*_ppStu[i])`，会发生**对象切片 (Slicing)**，丢失研究生特有的数据。
    
- **前置条件：** 为了正确实现，`Student` 类和 `Graduate` 类必须提供一个虚函数 `virtual Student* clone() const;`（原型模式），用来返回当前对象的一个深拷贝副本。
    
#### 代码实现



```C++
// 基类
class Student {
public:
    // 1. 声明为虚函数
    // const 是必须的，因为复制不应该修改原对象
    virtual Student* clone() const {
        return new Student(*this); // 调用 Student 的复制构造
    }
    virtual ~Student() {} 
};

// 派生类
class Graduate : public Student {
public:
    // 2. 重写 clone 函数
    // 注意：这里利用了“协变返回类型”，直接返回 Graduate*
    virtual Graduate* clone() const override {
        // 【关键】调用 Graduate 的复制构造函数
        return new Graduate(*this); 
    }
};
```
**代码实现：**



```C++
// 假设 Student 类中有 virtual Student* clone() const = 0;

// 复制构造函数
StudentList(const StudentList& other) 
    : _count(other._count), _available(other._available)
{
    // 1. 申请指针数组本身的空间
    _ppStu = new Student*[_available];

    // 2. 逐个克隆对象（深拷贝）
    for(int i = 0; i < _count; ++i)
    {
        // 必须调用 clone() 来处理多态，不能直接 new Student
        _ppStu[i] = other._ppStu[i]->clone(); 
    }
}

// 复制赋值运算符
StudentList& operator=(const StudentList& other)
{
    if (this != &other) // 自赋值检查
    {
        // 1. 清理旧资源
        for(int i = 0; i < _count; ++i) delete _ppStu[i];
        delete[] _ppStu;

        // 2. 复制新资源
        _count = other._count;
        _available = other._available;
        _ppStu = new Student*[_available];
        
        for(int i = 0; i < _count; ++i)
        {
            _ppStu[i] = other._ppStu[i]->clone();
        }
    }
    return *this;
}
```

---

### (2) 移动构造函数和移动赋值运算符

**结论：应该实现。**

- **理由：** `StudentList` 管理大量堆内存。如果发生类似 `list1 = createList();` 的操作，使用复制构造需要分配新内存并逐个克隆对象，开销巨大。移动语义可以直接“窃取”临时对象的指针数组，效率极高。
    

**代码实现：**



```C++
// 移动构造函数
StudentList(StudentList&& other) noexcept
    : _ppStu(other._ppStu), _count(other._count), _available(other._available)
{
    // 将源对象置为空状态，防止析构时释放资源
    other._ppStu = nullptr;
    other._count = 0;
    other._available = 0;
}

// 移动赋值运算符
StudentList& operator=(StudentList&& other) noexcept
{
    if (this != &other)
    {
        // 1. 释放自己的旧资源
        for(int i = 0; i < _count; ++i) delete _ppStu[i];
        delete[] _ppStu;

        // 2. 窃取对方资源
        _ppStu = other._ppStu;
        _count = other._count;
        _available = other._available;

        // 3. 将对方置为空
        other._ppStu = nullptr;
        other._count = 0;
        other._available = 0;
    }
    return *this;
}
```

---

### (3) 实现 add 函数

**注意点：**

1. **扩容逻辑：** 当 `_count >= _available` 时，数组空间不足，需要重新申请更大的数组（通常是 2 倍），拷贝旧指针，释放旧数组。
    
2. **Const转换：** 原型中参数是 `const Student*`，但我们存的是 `Student*`，需要 `const_cast`（这是该原型设计的一个小妥协，或者通常容器不应该修改存入的对象）。
    
3. **所有权转移：** 题目明确说“内存交给 StudentList 管理”，所以直接存指针，不需要 `new` 新对象。
    



```C++
Student* StudentList::add(const Student* p)
{
    // 1. 检查是否需要扩容
    if (_count >= _available)
    {
        int newSize = (_available == 0) ? 4 : _available * 2;
        Student** temp = new Student*[newSize];
        
        // 拷贝旧指针（注意：这里只拷贝指针本身，不拷贝学生对象）
        for(int i = 0; i < _count; ++i)
        {
            temp[i] = _ppStu[i];
        }
        
        // 释放旧数组（只删数组，不删学生对象）
        delete[] _ppStu; 
        
        _ppStu = temp;
        _available = newSize;
    }

    // 2. 添加新指针
    // 题目要求 p 是 const，但数组是 non-const，必须转换所有权
    // 注意：这里假设 p 指向的是堆内存且不再被外部 delete
    _ppStu[_count] = const_cast<Student*>(p);
    
    _count++;
    
    // 返回刚刚添加的指针
    return _ppStu[_count - 1];
}
```

---

### (4) 程序段分析

**结论：不合适，存在严重错误。**

**错误分析：**

1. **Snippet A (正确):** `Student * s = new Student(...)`。这是在**堆(Heap)**上分配内存。`add(s)` 后，`StudentList` 接管该指针，析构时会 `delete` 它。这是正确的。
    
2. **Snippet B (错误):** `Graduate g(...)`。这是在**栈(Stack)**上分配的局部对象。
    
    - `stuList.add(&g)` 把栈地址存入了容器。
        
    - **后果 1（双重释放）：** 当 `else` 块结束或 `for` 循环迭代时，局部变量 `g` 会自动析构。之后 `StudentList` 析构时，会再次尝试 `delete` 这个地址。
        
    - **后果 2（非法释放）：** `delete` 只能用于释放 `new` 分配的内存。对栈地址调用 `delete` 会导致程序崩溃。
        

**修正方法：** `Graduate` 也必须使用 `new` 创建：

C++

```
Graduate* g = new Graduate(i, "lisi", ...);
stuList.add(g);
```

---

### (5) 析构函数实现

析构函数负责清理所有管理的内存。由于 `StudentList` 拥有对象的所有权，它必须负责删除每一个学生对象。

C++

```
StudentList::~StudentList()
{
    // 1. 释放每一个学生对象（调用虚析构函数）
    if (_ppStu != nullptr)
    {
        for (int i = 0; i < _count; ++i)
        {
            delete _ppStu[i]; 
        }
        
        // 2. 释放指针数组本身
        delete[] _ppStu;
        _ppStu = nullptr;
    }
}
```

---

### (6) 扩展的文件读写类

**核心思路：**

- **写文件：** 遍历数组，对于每个对象，先写入一个**类型标记**（比如 1 代表 Student，2 代表 Graduate），然后调用对象的虚函数 `write`。
    
- **读文件：** 循环读取。先读**类型标记**。如果是 1，`new Student`；如果是 2，`new Graduate`。然后调用对象的虚函数 `read`。
    

C++

```
class FileStudentList : public StudentList
{
public:
    void save(const char* filename)
    {
        ofstream out(filename);
        out << _count << endl; // 先存数量
        
        for(int i = 0; i < _count; ++i)
        {
            // 利用 RTTI 判断类型，写入标记
            // 或者假设 Student/Graduate 有 getType() 虚函数
            if (dynamic_cast<Graduate*>(_ppStu[i])) 
            {
                out << 2 << endl; // 标记 2：研究生
            }
            else
            {
                out << 1 << endl; // 标记 1：本科生
            }
            // 多态调用 write
            _ppStu[i]->write(out);
        }
        out.close();
    }

    void load(const char* filename)
    {
        ifstream in(filename);
        int num, type;
        in >> num; // 读数量
        
        for(int i = 0; i < num; ++i)
        {
            in >> type; // 读标记
            Student* p = nullptr;
            
            if (type == 1)
                p = new Student();
            else if (type == 2)
                p = new Graduate();
                
            if (p)
            {
                p->read(in); // 多态读取数据
                this->add(p); // 加入列表
            }
        }
        in.close();
    }
};
```

---

### 2. 继承与组合 (Inheritance vs Composition)

**问题：使用它们时需要考虑什么？**

这是一个关于软件设计原则的问题。

1. **IS-A vs HAS-A 关系：**
    
    - **继承 (Inheritance):** 适用于 **"Is-a" (是一个)** 的关系。例如：研究生 **是** 学生。继承提供了**接口复用**和**实现复用**。必须遵守 **里氏替换原则 (LSP)**，即子类必须能完全替换父类。
        
    - **组合 (Composition):** 适用于 **"Has-a" (有一个)** 的关系。例如：学生 **有** 一个导师（导师类作为成员变量）。
        
2. **耦合度 (Coupling):**
    
    - **继承是“白盒”复用：** 破坏了封装性，子类通常知道父类的内部细节。父类变动，子类必须变动（高耦合）。
        
    - **组合是“黑盒”复用：** 对象只通过接口访问被包含对象的行为。被包含对象内部改变不影响包含类（低耦合）。
        
3. **动态性 (Flexibility):**
    
    - **继承：** 关系在编译期确定，无法在运行时改变。
        
    - **组合：** 可以在运行时改变行为（例如：通过策略模式，改变成员指针指向不同的对象）。
        
4. **选择建议：**
    
    - **优先使用组合，而非继承 (Composition over Inheritance)。** 除非你需要向上转型（多态）或者明确的“是一个”关系，否则组合通常更灵活、更健壮
---

### 第二部分：模板 (Templates)

#### 1. 函数模板实参推导 (Source 109-119)

- `Max(2, i)` (i 是 const int): `T` 推导为 `int`。
    
- `Max(d1, d2)`: `T` 推导为 `double`。
    
- `Max<double>(i, d1)`: 显式指定 `T=double`，`i` 隐式转换为 double。
    
- `Max(s1, s2)`: `T` 推导为 `MyString`。要求 `MyString` 重载了 `operator>`。
    

#### 2. 引用类型的模板 (Source 120-127)

`template<typename T> T Max(T& a, T& b)`

- `Max(2, i)`: **编译错误**。`2` 是右值 (R-value)，`int&` 不能绑定到右值。必须用 `const T&` 或右值引用。
    

#### 3. 值传递模板与 Decay (Source 129-142)

`template<typename T> T func(T a)` (值传递)

- `func(i)` (const int): `T` = `int` (顶层 const 被忽略)。
    
- `func(a)` (数组): `T` = `int*` (数组退化为指针)。
    
- `func("C++")`: `T` = `const char*`。
    

#### 4. 非类型模板参数 (Source 144-146)

- `print<i>(array)`: 错误。模板参数 `num` 必须是**编译期常量 (Compile-time constant)**。变量 `i` 只是普通变量。应改为 `const int i = 5;` 或者 `constexpr int i = 5;`。
    

#### 5. Array 类模板实现 (Source 147-191)

这里涉及 SFINAE (`enable_if`) 和 完美转发。

- **赋值运算符 (模板版):** 允许 `Array<int> = Array<double>` (如果 double 能转 int)。
    
    C++
    
    ```
    template<typename T, int size, typename D>
    template<typename _T, typename>
    Array<T, size, D>& Array<T, size, D>::operator=(const Array<_T>& val) noexcept
    {
        // 逻辑：清空当前，拷贝 val 的数据（发生类型转换）
        // 注意：不同类型的 Array 是完全不同的类，不能直接访问私有成员，除非设为友元。
        // 这里假设有 get 方法或友元声明。
        return *this;
    }
    ```
    
- **Push Back (完美转发):**
    
    C++
    
    ```
    template<typename T, int size, typename D>
    template<typename _T, typename>
    void Array<T, size, D>::push_back(_T&& val)
    {
        if (_count >= _capacity) expand();
        // std::forward 保持值类别 (左值仍是左值，右值仍是右值)
        _data[_count++] = std::forward<_T>(val); 
    }
    ```
    

#### 6. 智能指针 Unique Ptr (Source 192-232)

- **Q: 为什么删除复制构造/赋值？**
    
    - `unique_ptr` 语义是**独占所有权**。如果允许复制，就会有两个指针指向同一块内存，导致 Double Free。
        
- **Q: 数组特化**
    
    - 主模板析构调用 `delete ptr`。
        
    - 数组特化 (`my_unique_ptr<T[]>`) 析构必须调用 `delete [] ptr`。
        
    - 数组特化需要提供 `operator[]`，通常不提供 `operator*` 和 `operator->` (因为指向的是数组首地址，行为像指针)。
        

---

### 第三部分：异常 (Exceptions)

#### 程序运行结果解析 (Source 234-265)

这是一个非常经典的**异常捕获与对象切片**的例子。

**代码流程分析：**

1. `try` 块开始。
    
2. 调用 `test()`。
    
3. `test()` 中：`Derived2 e;` -> **输出:** `default ctor of Derived2 is called` (注意：先构造基类 `Base` -> `Derived1` -> `Derived2`，但代码只在派生类构造里输出了)。
    
    - 补全构造输出：`Base` 无输出, `Derived1` 输出, `Derived2` 输出。
        
4. `throw e;` -> 抛出异常。
    
    - 抛出时会**复制**异常对象到专用的异常存储区。调用 `Derived2` 的复制构造。
        
    - **输出:** `copy ctor of Derived2 is called`。
        
5. `test()` 栈展开 (Stack Unwinding)：局部变量 `e` 被销毁。
    
    - **输出:** `detor of Derived2 is called` -> `Derived1` 析构 -> `Base` 析构。
        
6. `catch` 匹配：
    
    - 异常类型是 `Derived2`。
        
    - `catch(Base e)`: **按值捕获 (By Value)**。
        
    - 这会导致**对象切片 (Object Slicing)**。用 `Derived2` 的异常对象来初始化 `Base e`。
        
    - **这里不会调用 Base 的复制构造函数**（因为 Base 没有定义，编译器合成的不会输出），也不会表现出多态。
        
    - **输出:** `捕获到Base类型异常`。
        
7. `catch` 块结束：
    
    - `e` (Base类型) 销毁。**输出:** `detor of Base is called`。
        
    - 异常存储区中的临时对象 `Derived2` 销毁。**输出:** `detor of Derived2 is called` (及基类析构)。
        
8. `main` 继续。**输出:** `回到main函数。`
    

**核心知识点总结：**

- **按值 Catch:** 会发生切片，且多一次拷贝，无法多态。**永远建议 `catch(const Exception& e)`**。
    
- **栈展开:** `throw` 之后，当前作用域的栈对象会逆序析构。
    

---

### 建议的下一步

Would you like me to write out the full, compilable C++ code for the `StudentList` class or the `Array` template class, incorporating the fixes and "Allman" style we discussed?