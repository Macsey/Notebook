这是一个非常全面的C++期末复习题集，涵盖了面向对象编程核心（继承、多态）、泛型编程（模板）以及错误处理（异常）的重点难点。

鉴于你是一位大二学生，且有一定的计算机基础（CS、硬件、系统编程兴趣），我将以**“底层内存模型 + 语法特性解析 + 代码实现”**的思路为你逐一详细解析。

我将按照你偏好的 **Allman 风格**（独占一行的花括号）和 **CamelCase 命名法** 来编写示例代码，但题目中已有的函数名（如 `modify_score`）我会保持原样以对应题目。

---

### 第一部分：继承和多态 (Inheritance & Polymorphism)

#### 1. 对象模型与构造/析构 (Source 3-7)

> **Q:** `Student s1; Graduate s2;` 调用哪些函数？`s1` 和 `s2` 占用多少内存？

- **调用函数：**
    
    - `s1`: 调用 `Student` 的默认构造函数。
        
    - `s2`: 先调用 `Student` 的默认构造函数（基类部分），再调用 `Graduate` 的默认构造函数（派生类部分）、`_supervisor` (MyString) 的默认构造函数。
        
    - **析构顺序相反：** `s2` 销毁时，先析构 `Graduate` (及成员 `_supervisor`)，再析构 `Student`。
        
- **内存空间 (Sizeof)：**
    
    - **Student:** `sizeof(_number) + sizeof(_name) + sizeof(_major) + sizeof(_score)`。由于存在**虚函数**（题目提到析构函数为虚），对象内会增加一个 **vptr (虚函数指针)**，通常占 4 或 8 字节（取决于 32/64位系统）。注意**内存对齐 (Padding)**。
        
    - **Graduate:** `sizeof(Student)` (含基类数据+vptr) + `sizeof(_supervisor)`。不需要额外的 vptr，派生类共用基类的 vptr（但指向不同的 vtable）。
        

#### 2. 数组与指针的构造 (Source 8-12)

> **Q:** `Student * p = new Graduate[2]; delete [] p;`

- **构造函数：** `Student` 和 `Graduate` 必须有**无参默认构造函数**，因为数组初始化默认调用无参构造。
    
- **函数调用：**
    
    - `new`: 调用 2 次 `Student` 构造 -> 2 次 `Graduate` 构造。
        
    - `delete []`: **这是一个典型的未定义行为 (Undefined Behavior) 陷阱！**
        
        - 原因：`p` 是 `Student*` 类型，`delete [] p` 会根据 `sizeof(Student)` 来计算下一个元素的位置。但实际对象是 `Graduate`，大小不同。编译器无法正确找到第二个对象的地址进行析构。
            
        - **如果只是 `delete p` (单个对象)** 且基类析构是虚函数，则没问题。但 `delete []` 对多态数组支持极差，**切勿多态地使用对象数组**。
            

#### 3. 参数传递与对象切片 (Source 13-24)

> **Q:** `modify_score` 调用分析。

- `modify_score(s, 100)` (引用版): 传递引用，**不产生新对象**，不调用构造/析构。直接修改 `s`。
    
- `modify_score(&g, 100)` (指针版): 传递地址，**不产生新对象**。
    
    - 注意：虽然传的是 `Graduate*`，但参数接收是 `Student*`。由于 `set_score` 通常不是虚函数（或是基类函数），直接调用基类版本修改基类部分的 `_score`。
        

#### 4. 复制构造函数与深拷贝 (Source 25-41)

> **Q:** `fun(g)` 调用分析。

- `fun(Graduate& s)` 参数是引用，**不调用复制构造函数**。
    
- `s.get_name().set_string(...)`: 修改了对象内部数据。
    
- `return s`: **关键点！** 函数返回类型是 `Graduate`（值类型）。这里会调用 **`Graduate` 的复制构造函数**，将 `s` 拷贝到一个临时对象返回给调用者。
    
- **Source 32 的实现：** `: Student(g), _supervisor(g._supervisor)`。这是正确的写法，显式调用基类复制构造函数，处理基类部分数据。
    

#### 5. 错误的复制构造写法 (Source 42-46)

> **Q:** 如果复制构造函数写成 `Student::operator=(g)` 会怎样？



```C++
Graduate(const Graduate& g)
{
    Student::operator=(g); // 错误！
    _supervisor = g._supervisor;
}
```

- **解析：** 构造函数执行函数体之前，基类部分**已经被默认构造**（调用了 `Student()`）。
- **隐式基类初始化 (隐形步骤)**： 在进入 `{` 之前，编译器**必须**先构造父类部分。因为你没有在初始化列表中指定怎么构造，编译器只能默认调用**无参构造函数**。
    
    - **调用函数：** `Student()` (Student 的默认构造函数) 。
        
    - **后果：** 此时新对象的基类部分被初始化为一个“空”学生（由于默认构造函数通常为空或赋默认值）。
        
- **隐式成员初始化 (隐形步骤)**： 同样，`_supervisor` 成员也必须在进入函数体前初始化。
    
    - **调用函数：** `MyString()` (MyString 的默认构造函数)。
        
    - **后果：** 产生了一个空的导师名字对象。
        
- **执行函数体 - 基类赋值**： 进入函数体，执行 `Student::operator=(g);` 。
    
    - **调用函数：** `Student::operator=(const Student& s)` 。
        
    - **行为：** 这是一个**赋值操作**。它将 `g` 中的数据覆盖掉刚才第一步里生成的那个“空”学生的数据。
        
- **执行函数体 - 成员赋值**： 执行 `_supervisor = g._supervisor;` 。
    
    - **调用函数：** `MyString::operator=(const MyString&)` (MyString 的赋值运算符)。
        
    - **行为：** 将 `g` 的导师名字覆盖掉刚才第二步里生成的空名字。
- 这里你先创建了一个空的基类部分，然后立刻调用赋值运算符覆盖它。虽然结果可能正确，但效率低（构造+赋值），且如果 `Student` 没有默认构造函数，代码将无法编译。
    

#### 6. Graduate 赋值运算符 (Source 59)

需要先调用基类的赋值运算符，再处理自己的成员。



```C++
Graduate& operator=(const Graduate& s)
{
    if (this != &s)
    {
        Student::operator=(s); // 显式调用基类赋值运算符
        _supervisor = s._supervisor;
    }
    return *this;
}
```

#### 7. 移动语义 (Source 60)

- **需要吗？** 如果 `MyString` 管理堆内存（如 `char*`），实现移动构造/赋值能大幅提升性能（避免深拷贝）。
    
- **实现：** 使用 `std::move` 强制转换为右值引用。
    

C++

```
Graduate(Graduate&& s) noexcept 
    : Student(std::move(s)), _supervisor(std::move(s._supervisor)) 
{ 
}
```

#### 8. 虚函数 Write/Read (Source 61-68)
1. 为什么 `Student` 类的 `read` 函数要设为虚函数？

**核心原因：为了实现多态调用，确保“读完整”。**

- **场景假设：** 在实际的文件读取或管理系统中，我们通常会使用基类指针 `Student*` 来统一管理所有的学生对象（既包含本科生 `Student`，也包含研究生 `Graduate`）。
    
- **如果不设为虚函数：** 如果 `read` 只是普通成员函数，当我们使用 `Student* p = new Graduate();` 并没有虚函数机制时，执行 `p->read(in)`，编译器会根据指针类型（`Student*`）直接调用 `Student::read()`。
    
    - **后果：** 程序只会读取“学号、姓名、专业、成绩”，而**漏掉**了研究生独有的“导师姓名（_supervisor）”。这会导致数据读取不完整，甚至导致文件指针位置错乱。
        
- **设为虚函数后：** 编译器会通过指针指向的对象的 **vptr（虚函数指针）** 查找虚函数表。只要实际对象是 `Graduate`，就会正确调用 `Graduate::read()`，从而先读基类数据，再读导师数据 。
2. 根据题目给出的基类原型 `virtual Student * Student::read(istream & in);`，实现的核心逻辑是：**先调用父类读基础数据，再读自己的数据，最后返回自身指针。**
这里利用了 C++ 的**协变返回类型**特性（即派生类重写虚函数时，返回类型可以是基类返回类型的派生类指针）。虽然基类返回 `Student*`，但 `Graduate` 最好返回 `Graduate*`（更精确），当然返回 `Student*` 也是合法的。

**代码实现如下：**
```C++
// 假设这是在 Graduate 类内部或定义
Student* Graduate::read(istream & in)
{
    // 1. 显式调用基类的 read 函数，读取 name, major, score 等基础信息
    Student::read(in); 

    // 2. 调用成员对象 _supervisor (MyString) 的 read 函数读取导师信息
    _supervisor.read(in);

    // 3. 返回当前对象的地址
    return this; 
}
```
3.如果基类声明返回引用，`Graduate` 类应如何声明？

**题目条件：** 基类改为 `virtual Student& Student::read(istream & in);`

**解析：** 这涉及到 C++ 的**协变返回类型 (Covariant Return Types)** 规则。 当派生类覆盖（Override）基类的虚函数时，如果基类函数返回的是**基类的指针或引用**（如 `Student*` 或 `Student&`），派生类的覆盖函数可以返回**派生类的指针或引用**（如 `Graduate*` 或 `Graduate&`）。

**`Graduate` 类的声明应该如下（两种写法均可，建议第一种）：**

**写法 A（推荐，利用协变特性）：**

C++

```
// 返回类型改为 Graduate&，这提供了更强的类型信息
virtual Graduate& read(istream & in) override; 
```

- **为什么要虚函数？** 为了支持多态调用。`Student* p = new Graduate(...)`，调用 `p->write()` 时，如果不是虚函数，只会保存基类数据，丢失 `Graduate` 特有的 `_supervisor`。
    
- **Read 的协变返回类型：**
    
    - 如果基类声明 `virtual Student* read(...)`。
        
    - 派生类可以覆盖为 `virtual Graduate* read(...)`。这是 C++ 允许的**协变 (Covariant)**，即返回类型可以是基类返回类型的派生类指针/引用。
        

#### 9. 多重继承与构造顺序 (Source 69-78)

> `class C : public A, public B`

- **构造顺序：** 取决于**继承声明顺序**，而非初始化列表顺序。
    
    1. `A()`
        
    2. `B()`
        
    3. `s1` (MyString)
        
    4. `s2` (MyString)
        
    5. `C()` 构造函数体。
        

#### 10. StudentList 管理类 (Source 79-106)

### (1) 复制构造函数和复制赋值运算符

**结论：应该实现，且必须实现“深拷贝”。**

- **理由：** `StudentList` 内部有一个裸指针数组 `_ppStu`，且数组里存的也是指向堆内存的指针 `Student*`。
    
    - 如果使用默认的复制构造（浅拷贝），两个 `StudentList` 对象将指向同一块内存。当其中一个对象析构时，所有的学生对象都会被删除，另一个对象就变成了“悬空指针”，一旦使用或析构会导致程序崩溃（Double Free）。
        
- **实现难点（多态复制）：** 数组里存的是 `Student*`，但实际对象可能是 `Graduate`。如果我们只用 `new Student(*_ppStu[i])`，会发生**对象切片 (Slicing)**，丢失研究生特有的数据。
    
- **前置条件：** 为了正确实现，`Student` 类和 `Graduate` 类必须提供一个虚函数 `virtual Student* clone() const;`（原型模式），用来返回当前对象的一个深拷贝副本。
    
#### 代码实现



```C++
// 基类
class Student {
public:
    // 1. 声明为虚函数
    // const 是必须的，因为复制不应该修改原对象
    virtual Student* clone() const {
        return new Student(*this); // 调用 Student 的复制构造
    }
    virtual ~Student() {} 
};

// 派生类
class Graduate : public Student {
public:
    // 2. 重写 clone 函数
    // 注意：这里利用了“协变返回类型”，直接返回 Graduate*
    virtual Graduate* clone() const override {
        // 【关键】调用 Graduate 的复制构造函数
        return new Graduate(*this); 
    }
};
```
**代码实现：**



```C++
// 假设 Student 类中有 virtual Student* clone() const = 0;

// 复制构造函数
StudentList(const StudentList& other) 
    : _count(other._count), _available(other._available)
{
    // 1. 申请指针数组本身的空间
    _ppStu = new Student*[_available];

    // 2. 逐个克隆对象（深拷贝）
    for(int i = 0; i < _count; ++i)
    {
        // 必须调用 clone() 来处理多态，不能直接 new Student
        _ppStu[i] = other._ppStu[i]->clone(); 
    }
}

// 复制赋值运算符
StudentList& operator=(const StudentList& other)
{
    if (this != &other) // 自赋值检查
    {
        // 1. 清理旧资源
        for(int i = 0; i < _count; ++i) delete _ppStu[i];
        delete[] _ppStu;

        // 2. 复制新资源
        _count = other._count;
        _available = other._available;
        _ppStu = new Student*[_available];
        
        for(int i = 0; i < _count; ++i)
        {
            _ppStu[i] = other._ppStu[i]->clone();
        }
    }
    return *this;
}
```

---

### (2) 移动构造函数和移动赋值运算符

**结论：应该实现。**

- **理由：** `StudentList` 管理大量堆内存。如果发生类似 `list1 = createList();` 的操作，使用复制构造需要分配新内存并逐个克隆对象，开销巨大。移动语义可以直接“窃取”临时对象的指针数组，效率极高。
    

**代码实现：**



```C++
// 移动构造函数
StudentList(StudentList&& other) noexcept
    : _ppStu(other._ppStu), _count(other._count), _available(other._available)
{
    // 将源对象置为空状态，防止析构时释放资源
    other._ppStu = nullptr;
    other._count = 0;
    other._available = 0;
}

// 移动赋值运算符
StudentList& operator=(StudentList&& other) noexcept
{
    if (this != &other)
    {
        // 1. 释放自己的旧资源
        for(int i = 0; i < _count; ++i) delete _ppStu[i];
        delete[] _ppStu;

        // 2. 窃取对方资源
        _ppStu = other._ppStu;
        _count = other._count;
        _available = other._available;

        // 3. 将对方置为空
        other._ppStu = nullptr;
        other._count = 0;
        other._available = 0;
    }
    return *this;
}
```

---

### (3) 实现 add 函数

**注意点：**

1. **扩容逻辑：** 当 `_count >= _available` 时，数组空间不足，需要重新申请更大的数组（通常是 2 倍），拷贝旧指针，释放旧数组。
    
2. **Const转换：** 原型中参数是 `const Student*`，但我们存的是 `Student*`，需要 `const_cast`（这是该原型设计的一个小妥协，或者通常容器不应该修改存入的对象）。
    
3. **所有权转移：** 题目明确说“内存交给 StudentList 管理”，所以直接存指针，不需要 `new` 新对象。
    



```C++
Student* StudentList::add(const Student* p)
{
    // 1. 检查是否需要扩容
    if (_count >= _available)
    {
        int newSize = (_available == 0) ? 4 : _available * 2;
        Student** temp = new Student*[newSize];
        
        // 拷贝旧指针（注意：这里只拷贝指针本身，不拷贝学生对象）
        for(int i = 0; i < _count; ++i)
        {
            temp[i] = _ppStu[i];
        }
        
        // 释放旧数组（只删数组，不删学生对象）
        delete[] _ppStu; 
        
        _ppStu = temp;
        _available = newSize;
    }

    // 2. 添加新指针
    // 题目要求 p 是 const，但数组是 non-const，必须转换所有权
    // 注意：这里假设 p 指向的是堆内存且不再被外部 delete
    _ppStu[_count] = const_cast<Student*>(p);
    
    _count++;
    
    // 返回刚刚添加的指针
    return _ppStu[_count - 1];
}
```

---

### (4) 程序段分析

**结论：不合适，存在严重错误。**

**错误分析：**

1. **Snippet A (正确):** `Student * s = new Student(...)`。这是在**堆(Heap)**上分配内存。`add(s)` 后，`StudentList` 接管该指针，析构时会 `delete` 它。这是正确的。
    
2. **Snippet B (错误):** `Graduate g(...)`。这是在**栈(Stack)**上分配的局部对象。
    
    - `stuList.add(&g)` 把栈地址存入了容器。
        
    - **后果 1（双重释放）：** 当 `else` 块结束或 `for` 循环迭代时，局部变量 `g` 会自动析构。之后 `StudentList` 析构时，会再次尝试 `delete` 这个地址。
        
    - **后果 2（非法释放）：** `delete` 只能用于释放 `new` 分配的内存。对栈地址调用 `delete` 会导致程序崩溃。
        

**修正方法：** `Graduate` 也必须使用 `new` 创建：

C++

```
Graduate* g = new Graduate(i, "lisi", ...);
stuList.add(g);
```

---

### (5) 析构函数实现

析构函数负责清理所有管理的内存。由于 `StudentList` 拥有对象的所有权，它必须负责删除每一个学生对象。


```C++

StudentList::~StudentList()
{
    // 1. 释放每一个学生对象（调用虚析构函数）
    if (_ppStu != nullptr)
    {
        for (int i = 0; i < _count; ++i)
        {
            delete _ppStu[i]; 
        }
        
        // 2. 释放指针数组本身
        delete[] _ppStu;
        _ppStu = nullptr;
    }
}
```

---

### (6) 扩展的文件读写类

**核心思路：**

- **写文件：** 遍历数组，对于每个对象，先写入一个**类型标记**（比如 1 代表 Student，2 代表 Graduate），然后调用对象的虚函数 `write`。
    
- **读文件：** 循环读取。先读**类型标记**。如果是 1，`new Student`；如果是 2，`new Graduate`。然后调用对象的虚函数 `read`。
    



```C++
class FileStudentList : public StudentList
{
public:
    void save(const char* filename)
    {
        ofstream out(filename);
        out << _count << endl; // 先存数量
        
        for(int i = 0; i < _count; ++i)
        {
            // 利用 RTTI 判断类型，写入标记
            // 或者假设 Student/Graduate 有 getType() 虚函数
            if (dynamic_cast<Graduate*>(_ppStu[i])) 
            {
                out << 2 << endl; // 标记 2：研究生
            }
            else
            {
                out << 1 << endl; // 标记 1：本科生
            }
            // 多态调用 write
            _ppStu[i]->write(out);
        }
        out.close();
    }

    void load(const char* filename)
    {
        ifstream in(filename);
        int num, type;
        in >> num; // 读数量
        
        for(int i = 0; i < num; ++i)
        {
            in >> type; // 读标记
            Student* p = nullptr;
            
            if (type == 1)
                p = new Student();
            else if (type == 2)
                p = new Graduate();
                
            if (p)
            {
                p->read(in); // 多态读取数据
                this->add(p); // 加入列表
            }
        }
        in.close();
    }
};
```

---

### 2. 继承与组合 (Inheritance vs Composition)

**问题：使用它们时需要考虑什么？**

这是一个关于软件设计原则的问题。

1. **IS-A vs HAS-A 关系：**
    
    - **继承 (Inheritance):** 适用于 **"Is-a" (是一个)** 的关系。例如：研究生 **是** 学生。继承提供了**接口复用**和**实现复用**。必须遵守 **里氏替换原则 (LSP)**，即子类必须能完全替换父类。
        
    - **组合 (Composition):** 适用于 **"Has-a" (有一个)** 的关系。例如：学生 **有** 一个导师（导师类作为成员变量）。
        
2. **耦合度 (Coupling):**
    
    - **继承是“白盒”复用：** 破坏了封装性，子类通常知道父类的内部细节。父类变动，子类必须变动（高耦合）。
        
    - **组合是“黑盒”复用：** 对象只通过接口访问被包含对象的行为。被包含对象内部改变不影响包含类（低耦合）。
        
3. **动态性 (Flexibility):**
    
    - **继承：** 关系在编译期确定，无法在运行时改变。
        
    - **组合：** 可以在运行时改变行为（例如：通过策略模式，改变成员指针指向不同的对象）。
        
4. **选择建议：**
    
    - **优先使用组合，而非继承 (Composition over Inheritance)。** 除非你需要向上转型（多态）或者明确的“是一个”关系，否则组合通常更灵活、更健壮
---

### 第二部分：模板 (Templates)

#### 1. 函数模板实参推导 (Source 109-119)

- `Max(2, i)` (i 是 const int): `T` 推导为 `int`。
    
- `Max(d1, d2)`: `T` 推导为 `double`。
    
- `Max<double>(i, d1)`: 显式指定 `T=double`，`i` 隐式转换为 double。
    
- `Max(s1, s2)`: `T` 推导为 `MyString`。要求 `MyString` 重载了 `operator>`。
    

#### 2. 引用类型的模板 (Source 120-127)


这两个函数调用在标准 C++ 中都会导致**编译错误**。

这一题主要考察的是 **`T&`（非 const 左值引用）** 作为函数参数时的**类型推导规则**以及**对右值/临时对象的绑定限制**。这与上一题（使用 `const T&`）有本质区别。

以下是详细解析：

### 1. `const int i = 1; Max(2, i);`

- **结果：** **编译错误 (Compilation Error)**
    
- **无法推导出 T 的类型**，且存在右值绑定问题。
    
    - **理由 1：类型推导冲突 (Ambiguity)**
        
        - 实参 `2` 是 `int` 类型。根据第一个参数 `a`，编译器推导 `T` 为 `int`。
            
        - 实参 `i` 是 `const int` 类型 。根据第二个参数 `b`（`T&`），编译器推导 `T` 为 `const int`。
            
        - 由于 `int` 和 `const int` 不一致，推导失败。
            
    - **理由 2：引用绑定限制**
        
        - 即使假设 `T` 被推导为 `int`，函数参数类型变为 `int&`（非 const 左值引用）。
            
        - 实参 `2` 是一个**右值 (R-value)**。
            
        - **C++ 规则：** 非 const 左值引用无法绑定到右值。
            

### 2. `double d = 1.1; Max<double>(i, d1);`

- **结果：** **模板实参为 `double`，但调用导致编译错误**
    
- **理由：**
    
    - 这里显式指定了模板实参 `T` 为 **`double`** 。因此函数签名变为： `double Max(double& a, double& b)`
        
    - **参数 1 分析：** 实参 `i` 是 `int` 类型。为了传递给 `double&`，编译器必须先将 `int` 转换为 `double`，这会产生一个**临时对象 (Temporary Object)**。
        
    - **错误点：** 函数参数 `a` 是 `double&`（非 const 左值引用）。
        
    - **C++ 规则：** 非 const 左值引用**不能**绑定到临时对象（临时对象被视为右值）。编译器为了保护数据（防止你修改了一个实际上即将销毁的临时变量），禁止了这种操作。
#### 3. 值传递模板与 Decay (Source 129-142)
#### `const int i = 1; func(i);`

- **推导结果 T：** `int`
    
- **解析：** 实参 `i` 是 `const int`。但在按值传递时，顶层 `const` 被忽略。参数 `a` 只是 `i` 的一个拷贝，类型为 `int`。
    

#### 2. `int j = 1; func(j);`

- **推导结果 T：** `int`
    
- **解析：** 实参 `j` 是 `int`，直接推导为 `int`。
    

#### 3. `func(3);`

- **推导结果 T：** `int`
    
- **解析：** 实参 `3` 是字面量，类型为 `int`。
    

#### 4. `func(move(j));`

- **推导结果 T：** `int`
    
- **解析：** `move(j)` 返回的是 `int&&`（右值引用）。但因为函数接受的是值 `T a`，这里发生了移动构造（或者拷贝构造，对于 int 来说是一样的）。参数 `a` 最终还是一个 `int` 类型的变量。`T` 描述的是对象的类型，而不是引用的类型。
    

#### 5. `int a[2] = { 1, 2 }; func(a);`

- **推导结果 T：** `int*`
    
- **解析：** **数组退化**。实参是数组 `int[2]`。按值传递时，数组退化为指向首元素的指针 `int*`。
    

#### 6. `const int b[2] = { 1, 2 }; func(b);`

- **推导结果 T：** `const int*`
    
- **解析：** **带 const 的数组退化**。实参是 `const int[2]`。它退化为指向首元素的指针。因为元素本身是 `const int`，所以指针类型是 `const int*`（指向常量的指针）。
    
    - _注意：这里的 const 是底层的（Low-level const），修饰的是数据，所以不会被忽略。_
        

#### 7. `func("C++");`

- **推导结果 T：** `const char*`
    
- **解析：** 字符串字面量 `"C++"` 的类型实际上是 `const char[4]`（包含结尾的 `\0`）。按值传递时，数组退化为指针 `const char*`。
    

#### 8. `func<char>(i);`

- **推导结果 T：** `char`
    
- **解析：** **显式指定模板参数**。这里用户强制指定了 `<char>`，编译器不再进行推导。此时函数原型变为 `char func(char a)`。实参 `i` (int) 会发生隐式类型转换（截断）传递给参数 `a`。

#### 4. 非类型模板参数 (Source 144-146)

- `print<i>(array)`: 错误。模板参数 `num` 必须是**编译期常量 (Compile-time constant)**。变量 `i` 只是普通变量。应改为 `const int i = 5;` 或者 `constexpr int i = 5;`。
    

#### 5. Array 类模板实现 (Source 147-191)


### (1) 成员函数 `Array& operator=(const Array& val)` 的实现

这是标准的**复制赋值运算符**。由于类管理了堆内存（`_data`），必须实现**深拷贝**以防止内存泄漏和双重释放。

**实现逻辑：**

1. **自赋值检查**：避免自己给自己赋值时误删数据。
    
2. **释放旧内存**：防止内存泄漏。
    
3. **分配新内存**：根据源对象的容量申请空间。
    
4. **拷贝数据**：逐个复制元素。
    
5. **更新成员变量**：更新计数和容量。
    



```C++
template<typename T, int size, typename D>
Array<T, size, D>& Array<T, size, D>::operator=(const Array& val)
{
    // 1. 自赋值检查
    if (this != &val)
    {
        // 2. 释放旧资源
        delete[] _data;

        // 3. 复制元数据
        _count = val._count;
        _capacity = val._capacity;

        // 4. 分配新资源并深拷贝数据
        _data = new T[_capacity];
        for (int i = 0; i < _count; ++i)
        {
            _data[i] = val._data[i];
        }
    }
    
    // 5. 返回自身引用
    return *this;
}
```

---

### (2) 模板赋值运算符 `operator=(const Array<_T>& val)` 的实现

这个函数允许将一个保存不同类型数据（但可转换，如 `int` 到 `double`）的 `Array` 赋值给当前对象。

**注意：**

- 这是一个**函数模板**，定义在类模板外部时，需要两层 `template` 声明。
    
- 由于 `Array<_T>` 和 `Array<T>` 是两个不同的类类型，按照标准 C++ 访问控制，不能直接访问 `val._data`（除非声明为友元）。但在考试或练习场景下，通常假设已声明友元类 `template<typename U, int s, typename E> friend class Array;`，或者通过 `get` 方法访问。此处按直接访问（友元存在）编写。
    

C++

```
// 类模板参数
template<typename T, int size, typename D>
// 成员函数模板参数 (利用 SFINAE 限制类型转换)
template<typename _T, typename _D>
Array<T, size, D>& Array<T, size, D>::operator=(const Array<_T>& val) noexcept
{
    // 这里不需要像同类型赋值那样严格检查 this != &val，
    // 因为 Array<int> 和 Array<double> 的地址通常不会相同且类型不同。

    // 1. 释放旧资源
    delete[] _data;

    // 2. 复制元数据
    // 注意：如果是严格的私有访问，这里需要 val 提供 public 接口
    _count = val._count;       
    _capacity = val._capacity; 

    // 3. 分配新资源
    _data = new T[_capacity];

    // 4. 拷贝数据（发生隐式类型转换 _T -> T）
    for (int i = 0; i < _count; ++i)
    {
        _data[i] = static_cast<T>(val._data[i]); 
    }

    return *this;
}
```

---

### (3) 函数 `push_back(_T&& val)` 的实现与完美转发

此函数使用了**万能引用 (Universal Reference)** `_T&&` 和 **完美转发 (Perfect Forwarding)**。

**核心原理：**

- **万能引用**：当 `_T` 是模板参数且配合 `&&` 时，它既能接左值也能接右值。
    
- **完美转发 (`std::forward`)**：如果传入的是左值，它就按左值传给 `_data`；如果传入的是右值（临时对象），它就按右值传递，允许 `T` 类型进行移动赋值，从而避免不必要的拷贝。
    

C++

```
template<typename T, int size, typename D>
template<typename _T, typename _D>
void Array<T, size, D>::push_back(_T&& val)
{
    // 1. 检查容量，不足则扩容
    if (_count >= _capacity)
    {
        expand();
    }

    // 2. 插入元素，使用完美转发保持值类别
    // 如果 val 是右值，std::forward 会将其转为 T&&，触发 T 的移动赋值
    // 如果 val 是左值，std::forward 会将其转为 T&，触发 T 的拷贝赋值
    _data[_count++] = std::forward<_T>(val);
}
```

---

### (4) 流插入符函数与迭代器设计

#### A. 流插入符 `operator<<`

需要在类内部声明 `friend`，并在外部定义。

**类内声明（添加到 public 部分）：**

C++

```
// 需要重新声明模板参数，以免名字冲突
template<typename U, int s, typename E>
friend std::ostream& operator<<(std::ostream& out, const Array<U, s, E>& arr);
```

**类外定义：**

C++

```
template<typename T, int size, typename D>
std::ostream& operator<<(std::ostream& out, const Array<T, size, D>& arr)
{
    out << "[";
    for (int i = 0; i < arr._count; ++i)
    {
        out << arr._data[i];
        if (i < arr._count - 1)
        {
            out << ", ";
        }
    }
    out << "]";
    return out;
}
```

#### B. 迭代器 (Iterator) 设计

迭代器本质上是一个封装了指针的类，模仿指针的行为。通常作为嵌套类定义在 `Array` 内部。

**类内定义（嵌套类）：**

C++

```
// 在 class Array 的 public 区域中定义
class Iterator
{
public:
    [cite_start]// 1. 构造函数实现 [cite: 191]
    Iterator(T* ptr) : _ptr(ptr) { }

    // 2. 解引用运算符
    T& operator*() const { return *_ptr; }

    // 3. 指针运算符
    T* operator->() const { return _ptr; }

    // 4. 前置自增 (++it)
    Iterator& operator++() 
    { 
        ++_ptr; 
        return *this; 
    }

    // 5. 后置自增 (it++)
    Iterator operator++(int) 
    { 
        Iterator tmp = *this; 
        ++_ptr; 
        return tmp; 
    }

    // 6. 比较运算符
    bool operator!=(const Iterator& other) const { return _ptr != other._ptr; }
    bool operator==(const Iterator& other) const { return _ptr == other._ptr; }

private:
    T* _ptr; // 封装的原生指针
};

// 配合迭代器的 begin() 和 end() 函数
Iterator begin() { return Iterator(_data); }
Iterator end() { return Iterator(_data + _count); }
```

#### 6. 智能指针 Unique Ptr (Source 192-232)

- **Q: 为什么删除复制构造/赋值？**
    
    - `unique_ptr` 语义是**独占所有权**。如果允许复制，就会有两个指针指向同一块内存，导致 Double Free。
        
- **Q: 数组特化**
    
    - 主模板析构调用 `delete ptr`。
        
    - 数组特化 (`my_unique_ptr<T[]>`) 析构必须调用 `delete [] ptr`。
        
    - 数组特化需要提供 `operator[]`，通常不提供 `operator*` 和 `operator->` (因为指向的是数组首地址，行为像指针)。
        

---

### 第三部分：异常 (Exceptions)

#### 程序运行结果解析 (Source 234-265)

这是一个非常经典的**异常捕获与对象切片**的例子。

**代码流程分析：**

1. `try` 块开始。
    
2. 调用 `test()`。
    
3. `test()` 中：`Derived2 e;` -> **输出:** `default ctor of Derived2 is called` (注意：先构造基类 `Base` -> `Derived1` -> `Derived2`，但代码只在派生类构造里输出了)。
    
    - 补全构造输出：`Base` 无输出, `Derived1` 输出, `Derived2` 输出。
        
4. `throw e;` -> 抛出异常。
    
    - 抛出时会**复制**异常对象到专用的异常存储区。调用 `Derived2` 的复制构造。
        
    - **输出:** `copy ctor of Derived2 is called`。
        
5. `test()` 栈展开 (Stack Unwinding)：局部变量 `e` 被销毁。
    
    - **输出:** `detor of Derived2 is called` -> `Derived1` 析构 -> `Base` 析构。
        
6. `catch` 匹配：
    
    - 异常类型是 `Derived2`。
        
    - `catch(Base e)`: **按值捕获 (By Value)**。
        
    - 这会导致**对象切片 (Object Slicing)**。用 `Derived2` 的异常对象来初始化 `Base e`。
        
    - **这里不会调用 Base 的复制构造函数**（因为 Base 没有定义，编译器合成的不会输出），也不会表现出多态。
        
    - **输出:** `捕获到Base类型异常`。
        
7. `catch` 块结束：
    
    - `e` (Base类型) 销毁。**输出:** `detor of Base is called`。
        
    - 异常存储区中的临时对象 `Derived2` 销毁。**输出:** `detor of Derived2 is called` (及基类析构)。
        
8. `main` 继续。**输出:** `回到main函数。`
    

**核心知识点总结：**

- **按值 Catch:** 会发生切片，且多一次拷贝，无法多态。**永远建议 `catch(const Exception& e)`**。
    
- **栈展开:** `throw` 之后，当前作用域的栈对象会逆序析构。
    

---

### 建议的下一步

Would you like me to write out the full, compilable C++ code for the `StudentList` class or the `Array` template class, incorporating the fixes and "Allman" style we discussed?